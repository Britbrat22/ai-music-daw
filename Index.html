<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>AI DAW Pro</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #151520;
            --bg-track: #1a1a2e;
            --accent: #6366f1;
            --accent-hover: #818cf8;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --border: #2d3748;
            --record: #ef4444;
            --play: #10b981;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding-top: 60px;
        }

        /* Mobile Debug Console */
        #debugConsole {
            position: fixed;
            top: 70px;
            left: 10px;
            right: 10px;
            max-height: 200px;
            background: rgba(0,0,0,0.9);
            border: 2px solid #ef4444;
            color: #10b981;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            z-index: 99999;
            display: none;
            border-radius: 8px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        #startOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 15, 0.98);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            touch-action: manipulation;
        }

        #startOverlay h1 {
            background: linear-gradient(135deg, #818cf8, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2rem;
            text-align: center;
            padding: 0 20px;
        }

        #startOverlay button {
            padding: 1.5rem 3rem;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.4);
            touch-action: manipulation;
            -webkit-touch-callout: none;
            min-width: 200px;
        }

        #startOverlay button:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 60px;
            position: fixed;
            top: 0;
            width: 100%;
            z-index: 100;
        }

        .logo { font-size: 1.2rem; font-weight: bold; background: linear-gradient(135deg, #818cf8, #c084fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        .transport {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(0,0,0,0.3);
            padding: 0.25rem 0.5rem;
            border-radius: 30px;
            border: 1px solid var(--border);
        }

        .transport-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            background: var(--bg-track);
            color: var(--text);
            touch-action: manipulation;
        }

        .transport-btn:active { transform: scale(0.9); }
        .transport-btn.play { color: var(--play); border: 2px solid var(--play); }
        .transport-btn.play.active { background: var(--play); color: white; }

        .time-display {
            font-family: monospace;
            font-size: 1.2rem;
            color: var(--accent);
            min-width: 60px;
            text-align: center;
        }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            flex-direction: column; /* Stack on mobile */
        }

        @media (min-width: 768px) {
            .main-container { flex-direction: row; }
        }

        .track-panel {
            width: 100%;
            height: 30%;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        @media (min-width: 768px) {
            .track-panel { width: 250px; height: auto; }
        }

        .panel-header {
            padding: 0.75rem;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--border);
            font-weight: bold;
            color: var(--accent);
            font-size: 0.9rem;
        }

        .track-header {
            height: 80px;
            background: var(--bg-track);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .track-header.active { 
            background: rgba(99, 102, 241, 0.2); 
            border-left: 3px solid var(--accent); 
        }
        
        .track-name {
            font-weight: 600;
            color: var(--text);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

        .track-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .track-btn {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-dark);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
            touch-action: manipulation;
        }

        .track-btn.mute.active { background: #ef4444; color: white; border-color: #ef4444; }
        .track-btn.solo.active { background: #f59e0b; color: white; border-color: #f59e0b; }

        .fader-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: auto;
        }

        .fader {
            flex: 1;
            height: 30px; /* Larger for touch */
            -webkit-appearance: none;
            background: var(--bg-dark);
            border-radius: 3px;
            outline: none;
        }

        .fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-dark);
            height: 70%;
        }

        @media (min-width: 768px) {
            .timeline-container { height: auto; }
        }

        .timeline-tracks {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .timeline-track {
            height: 80px;
            border-bottom: 1px solid var(--border);
            background: rgba(26, 26, 46, 0.5);
            position: relative;
            overflow: hidden;
        }

        .clip {
            position: absolute;
            height: 60px;
            top: 10px;
            background: linear-gradient(135deg, var(--accent), #8b5cf6);
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid transparent;
            padding: 0 5px;
            min-width: 40px;
        }

        .clip.selected { border-color: white; box-shadow: 0 0 0 2px var(--accent); }

        .playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: var(--record);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 10px var(--record);
        }

        .toolbar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .tool-btn {
            padding: 0.75rem 1rem;
            background: var(--bg-track);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            white-space: nowrap;
            touch-action: manipulation;
        }

        .tool-btn:active { background: var(--accent); }

        input[type="file"] { display: none; }

        .status-msg {
            position: fixed;
            top: 70px;
            right: 10px;
            padding: 0.75rem;
            background: #10b981;
            color: white;
            border-radius: 8px;
            z-index: 9999;
            display: none;
            font-size: 0.9rem;
            max-width: 80%;
        }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
    </style>
</head>
<body>

<!-- Mobile Debug Console -->
<div id="debugConsole"></div>

<div id="startOverlay">
    <h1>üéπ AI DAW Pro</h1>
    <p style="color: var(--text-muted); text-align: center; padding: 0 20px; line-height: 1.5;">
        Tap below to start<br>
        <small>(iOS requires manual audio start)</small>
    </p>
    <button id="startBtn">‚ñ∂ Start Studio</button>
</div>

<div class="status-msg" id="statusMsg"></div>

<div class="toolbar">
    <button class="tool-btn" onclick="addAudioTrack()">üéµ Add Track</button>
    <button class="tool-btn" onclick="document.getElementById('fileInput').click()">üìÅ Import</button>
    <button class="tool-btn" onclick="generateAI()">ü§ñ AI Gen</button>
    <button class="tool-btn" onclick="showDebug()">üêõ Debug</button>
    <input type="file" id="fileInput" accept="audio/*" onchange="importAudio(event)">
</div>

<div class="main-container">
    <div class="track-panel" id="trackPanel">
        <div class="panel-header">Tracks</div>
        <div id="trackHeaders"></div>
    </div>

    <div class="timeline-container">
        <div class="timeline-tracks" id="timelineTracks">
            <div class="playhead" id="playhead" style="left: 0px;"></div>
            <div id="trackLanes"></div>
        </div>
    </div>
</div>

<div class="header">
    <div class="logo">üéπ AI DAW</div>
    
    <div class="transport">
        <button class="transport-btn" onclick="transportStop()">‚èπ</button>
        <button class="transport-btn play" id="playBtn" onclick="togglePlay()">‚ñ∂</button>
        <div class="time-display" id="timeDisplay">00:00</div>
    </div>
    
    <div style="color: var(--text-muted); font-size: 0.8rem;">
        <span id="trackCount">0</span>
    </div>
</div>

<script>
// Debug logging for mobile
const debugConsole = document.getElementById('debugConsole');
let debugLogs = [];

function log(msg, type = 'info') {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    debugLogs.push(line);
    if (debugLogs.length > 50) debugLogs.shift();
    
    if (debugConsole.style.display === 'block') {
        debugConsole.textContent = debugLogs.join('\n');
    }
    console.log(msg);
}

function showError(msg) {
    log('ERROR: ' + msg, 'error');
    showStatus('Error: ' + msg);
}

function showDebug() {
    debugConsole.style.display = debugConsole.style.display === 'block' ? 'none' : 'block';
    debugConsole.textContent = debugLogs.join('\n');
}

// Global State
let tracks = [];
let currentTrack = 0;
let isPlaying = false;
let currentTime = 0;
let pixelsPerSecond = 50;
let audioCtx;
let playheadInterval;
let isInitialized = false;

function showStatus(msg) {
    const status = document.getElementById('statusMsg');
    status.textContent = msg;
    status.style.display = 'block';
    setTimeout(() => status.style.display = 'none', 3000);
}

// iOS Audio Context initialization
async function initDAW() {
    log('Initializing DAW...');
    
    try {
        // iOS specific AudioContext creation
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) {
            throw new Error('Web Audio API not supported');
        }
        
        audioCtx = new AudioContext();
        log('AudioContext created, state: ' + audioCtx.state);
        
        // iOS requires resume after creation
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
            log('AudioContext resumed, new state: ' + audioCtx.state);
        }
        
        // Hide overlay
        const overlay = document.getElementById('startOverlay');
        overlay.style.opacity = '0';
        overlay.style.pointerEvents = 'none';
        setTimeout(() => {
            overlay.style.display = 'none';
        }, 500);
        
        isInitialized = true;
        
        // Add first track
        addAudioTrack();
        
        showStatus('Audio Started');
        log('DAW Initialized successfully');
        
        // iOS touch handler for audio context maintenance
        document.addEventListener('touchstart', async () => {
            if (audioCtx && audioCtx.state === 'suspended') {
                await audioCtx.resume();
                log('Resumed via touch');
            }
        }, { passive: true });
        
    } catch (err) {
        log('Init Error: ' + err.message);
        showError('Failed to start: ' + err.message);
    }
}

// Bind start button with both click and touch for iOS
const startBtn = document.getElementById('startBtn');
startBtn.addEventListener('click', initDAW);
startBtn.addEventListener('touchend', (e) => {
    e.preventDefault(); // Prevent double firing
    initDAW();
});

class Track {
    constructor(type = 'audio') {
        this.id = tracks.length;
        this.type = type;
        this.name = `Track ${this.id + 1}`;
        this.clips = [];
        this.volume = 0.8;
        this.pan = 0;
        this.mute = false;
        this.solo = false;
        
        if (isInitialized && audioCtx) {
            try {
                this.gainNode = audioCtx.createGain();
                this.pannerNode = audioCtx.createStereoPanner();
                this.gainNode.connect(this.pannerNode);
                this.pannerNode.connect(audioCtx.destination);
                this.gainNode.gain.value = this.volume;
                log(`Track ${this.id} audio nodes created`);
            } catch (e) {
                log('Track node error: ' + e.message);
            }
        }
        
        this.createDOM();
        updateTrackCount();
    }
    
    createDOM() {
        const header = document.createElement('div');
        header.className = 'track-header' + (this.id === currentTrack ? ' active' : '');
        header.innerHTML = `
            <div class="track-name">
                üéµ ${this.name}
                <span style="font-size: 0.7rem; opacity: 0.7;">${this.type}</span>
            </div>
            <div class="track-controls">
                <button class="track-btn mute" ontouchstart="toggleMute(${this.id}, event)" onclick="toggleMute(${this.id}, event)">M</button>
                <button class="track-btn solo" ontouchstart="toggleSolo(${this.id}, event)" onclick="toggleSolo(${this.id}, event)">S</button>
            </div>
            <div class="fader-container" ontouchend="event.stopPropagation()" onclick="event.stopPropagation()">
                <input type="range" class="fader" min="0" max="1" step="0.01" value="0.8" 
                    oninput="updateVolume(${this.id}, this.value)" ontouchend="event.stopPropagation()">
            </div>
        `;
        header.onclick = () => selectTrack(this.id);
        document.getElementById('trackHeaders').appendChild(header);
        
        const lane = document.createElement('div');
        lane.className = 'timeline-track';
        lane.id = `lane-${this.id}`;
        document.getElementById('trackLanes').appendChild(lane);
    }
}

function updateTrackCount() {
    document.getElementById('trackCount').textContent = tracks.length;
}

function addAudioTrack() {
    try {
        tracks.push(new Track('audio'));
        log('Added track ' + tracks.length);
    } catch (err) {
        showError('Add track failed: ' + err.message);
    }
}

function selectTrack(id) {
    currentTrack = id;
    document.querySelectorAll('.track-header').forEach((h, i) => {
        h.classList.toggle('active', i === id);
    });
    log('Selected track ' + (id + 1));
}

function toggleMute(id, e) {
    try {
        tracks[id].mute = !tracks[id].mute;
        if (tracks[id].gainNode) {
            tracks[id].gainNode.gain.value = tracks[id].mute ? 0 : tracks[id].volume;
        }
        e.target.classList.toggle('active', tracks[id].mute);
        log(`Track ${id+1} mute: ${tracks[id].mute}`);
    } catch (err) {
        showError('Mute error: ' + err.message);
    }
}

function toggleSolo(id, e) {
    try {
        tracks[id].solo = !tracks[id].solo;
        e.target.classList.toggle('active', tracks[id].solo);
        log(`Track ${id+1} solo: ${tracks[id].solo}`);
    } catch (err) {
        showError('Solo error: ' + err.message);
    }
}

function updateVolume(id, val) {
    try {
        const vol = parseFloat(val);
        tracks[id].volume = vol;
        if (!tracks[id].mute && tracks[id].gainNode) {
            tracks[id].gainNode.gain.value = vol;
        }
    } catch (err) {
        showError('Volume error: ' + err.message);
    }
}

async function togglePlay() {
    if (!isInitialized) {
        showStatus('Tap Start Studio first!');
        return;
    }
    
    log('Toggle play, current: ' + isPlaying);
    
    if (isPlaying) {
        pauseTransport();
    } else {
        await startTransport();
    }
}

async function startTransport() {
    if (!audioCtx) {
        showError('No audio context');
        return;
    }
    
    try {
        if (audioCtx.state === 'suspended') {
            await audioCtx.resume();
            log('Resumed AudioContext for playback');
        }
        
        isPlaying = true;
        document.getElementById('playBtn').classList.add('active');
        document.getElementById('playBtn').textContent = '‚è∏';
        
        const startTime = audioCtx.currentTime;
        const startPos = currentTime;
        
        log('Starting playback at ' + startPos);
        
        // Schedule clips
        tracks.forEach((track, idx) => {
            track.clips.forEach((clip, cidx) => {
                if (!clip.buffer || !track.gainNode) return;
                
                try {
                    const clipEnd = clip.startTime + clip.duration;
                    
                    if (clip.startTime <= currentTime && clipEnd > currentTime) {
                        // Resume mid-clip
                        const source = audioCtx.createBufferSource();
                        source.buffer = clip.buffer;
                        source.connect(track.gainNode);
                        const offset = currentTime - clip.startTime;
                        source.start(startTime, offset);
                        clip.source = source;
                        log(`Track ${idx} clip ${cidx}: resume from ${offset.toFixed(2)}`);
                    } else if (clip.startTime > currentTime) {
                        // Future clip
                        const source = audioCtx.createBufferSource();
                        source.buffer = clip.buffer;
                        source.connect(track.gainNode);
                        const when = startTime + (clip.startTime - currentTime);
                        source.start(when);
                        clip.source = source;
                    }
                } catch (e) {
                    log(`Clip error: ${e.message}`);
                }
            });
        });
        
        playheadInterval = setInterval(() => {
            const elapsed = audioCtx.currentTime - startTime;
            currentTime = startPos + elapsed;
            updatePlayhead();
        }, 50);
        
    } catch (err) {
        showError('Playback error: ' + err.message);
        isPlaying = false;
    }
}

function pauseTransport() {
    isPlaying = false;
    document.getElementById('playBtn').classList.remove('active');
    document.getElementById('playBtn').textContent = '‚ñ∂';
    clearInterval(playheadInterval);
    log('Paused at ' + currentTime.toFixed(2));
    
    tracks.forEach(track => {
        track.clips.forEach(clip => {
            if (clip.source) {
                try { clip.source.stop(); } catch(e) {}
                clip.source = null;
            }
        });
    });
}

function transportStop() {
    pauseTransport();
    currentTime = 0;
    updatePlayhead();
    log('Stopped');
}

function updatePlayhead() {
    const pos = currentTime * pixelsPerSecond;
    document.getElementById('playhead').style.left = pos + 'px';
    
    const mins = Math.floor(currentTime / 60).toString().padStart(2, '0');
    const secs = Math.floor(currentTime % 60).toString().padStart(2, '0');
    document.getElementById('timeDisplay').textContent = `${mins}:${secs}`;
}

function importAudio(event) {
    if (!audioCtx) {
        showError('Start audio engine first');
        return;
    }
    
    try {
        const file = event.target.files[0];
        if (!file) return;
        
        log('Importing: ' + file.name);
        showStatus('Importing...');
        
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const arrayBuffer = e.target.result;
                log('Decoding audio...');
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                
                const clip = {
                    id: Date.now(),
                    buffer: audioBuffer,
                    startTime: currentTime,
                    duration: audioBuffer.duration,
                    name: file.name.substring(0, 10)
                };
                
                tracks[currentTrack].clips.push(clip);
                renderClip(clip, currentTrack);
                showStatus('Imported!');
                log('Import success, duration: ' + audioBuffer.duration.toFixed(2));
            } catch (err) {
                showError('Decode failed: ' + err.message);
            }
        };
        reader.readAsArrayBuffer(file);
    } catch (err) {
        showError('Import error: ' + err.message);
    }
}

function renderClip(clip, trackId) {
    const lane = document.getElementById(`lane-${trackId}`);
    if (!lane) return;
    
    const div = document.createElement('div');
    div.className = 'clip';
    div.id = `clip-${clip.id}`;
    div.style.left = (clip.startTime * pixelsPerSecond) + 'px';
    div.style.width = Math.max((clip.duration * pixelsPerSecond), 40) + 'px';
    div.textContent = clip.name;
    div.title = clip.name;
    div.ontouchstart = div.onclick = (e) => {
        e.stopPropagation();
        selectClip(clip.id);
    };
    lane.appendChild(div);
}

function selectClip(id) {
    document.querySelectorAll('.clip').forEach(c => c.classList.remove('selected'));
    const clip = document.getElementById(`clip-${id}`);
    if (clip) clip.classList.add('selected');
}

function generateAI() {
    if (!audioCtx) {
        showError('Start audio first!');
        return;
    }
    
    try {
        log('Generating AI melody...');
        const duration = 4;
        const sampleRate = audioCtx.sampleRate;
        const buffer = audioCtx.createBuffer(2, duration * sampleRate, sampleRate);
        
        const freqs = [261.63, 329.63, 392.00, 523.25];
        
        for (let i = 0; i < 4; i++) {
            const freq = freqs[i];
            const start = i * (duration / 4) * sampleRate;
            const end = start + (0.5 * sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const data = buffer.getChannelData(channel);
                for (let j = start; j < end && j < data.length; j++) {
                    const t = (j - start) / sampleRate;
                    data[j] = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 4) * 0.3;
                }
            }
        }
        
        const clip = {
            id: Date.now(),
            buffer: buffer,
            startTime: currentTime,
            duration: duration,
            name: 'AI Melody'
        };
        
        tracks[currentTrack].clips.push(clip);
        renderClip(clip, currentTrack);
        showStatus('AI Generated!');
        log('AI generation complete');
    } catch (err) {
        showError('AI Gen failed: ' + err.message);
    }
}

// Handle visibility change
document.addEventListener('visibilitychange', () => {
    if (document.hidden && isPlaying) {
        pauseTransport();
        log('Auto-paused (background)');
    }
});

// iOS prevents default touch behaviors
document.addEventListener('touchmove', function(e) {
    if (e.target.closest('.timeline-tracks') || e.target.closest('.track-panel')) {
        // Allow scrolling in these areas
    } else {
        // e.preventDefault(); // Uncomment if you want to prevent bounce
    }
}, { passive: true });

log('Page loaded, waiting for start...');
</script>

</body>
</html>
