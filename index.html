<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Vocal Studio Pro - Fixed Playback</title>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            min-height: 100vh;
            color: #e0e7ff;
        }

        .container { max-width: 1400px; margin: 0 auto; padding: 2rem; }

        header { text-align: center; margin-bottom: 2rem; }
        h1 { font-size: 2.5rem; background: linear-gradient(to right, #818cf8, #c084fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        .tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: rgba(129, 140, 248, 0.1);
            border: 2px solid #818cf8;
            color: #e0e7ff;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .tab.active {
            background: linear-gradient(135deg, #818cf8, #c084fc);
            border-color: transparent;
            color: white;
        }

        .upload-zone {
            border: 3px dashed #818cf8;
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            background: rgba(30, 41, 75, 0.5);
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 2rem;
        }

        .upload-zone:hover { border-color: #c084fc; transform: translateY(-2px); }
        input[type="file"] { display: none; }

        .editor-container {
            display: none;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 20px;
            padding: 2rem;
            border: 1px solid rgba(129, 140, 248, 0.2);
        }

        .waveform-container {
            background: #0f172a;
            border-radius: 15px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        #waveform { width: 100%; height: 150px; }

        .controls-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .panel {
            background: rgba(30, 41, 75, 0.6);
            border-radius: 15px;
            padding: 1.5rem;
            border: 1px solid rgba(129, 140, 248, 0.3);
        }

        .panel h3 {
            color: #c084fc;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .control {
            margin-bottom: 1rem;
        }

        .control label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: #a5b4fc;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: #1e293b;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px; height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #818cf8, #c084fc);
            cursor: pointer;
        }

        button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            margin: 0.25rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, #818cf8, #c084fc);
            color: white;
        }
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(129, 140, 248, 0.4); }

        .btn-success {
            background: linear-gradient(135deg, #34d399, #10b981);
            color: white;
            padding: 1rem 2rem;
            font-size: 1.1rem;
        }

        .btn-secondary {
            background: rgba(129, 140, 248, 0.2);
            color: #e0e7ff;
            border: 1px solid #818cf8;
        }

        .play-btn {
            width: 80px; height: 80px;
            border-radius: 50%;
            font-size: 2rem;
            background: linear-gradient(135deg, #818cf8, #c084fc);
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 20px rgba(129, 140, 248, 0.3);
        }

        .play-btn:hover { 
            transform: scale(1.1); 
            box-shadow: 0 0 40px rgba(129, 140, 248, 0.6); 
        }
        
        .play-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            position: fixed;
            top: 20px; right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 10px;
            display: none;
            z-index: 1000;
            color: white;
            font-weight: 500;
        }
        .status.show { display: block; }
        .status.success { background: rgba(52, 211, 153, 0.9); }
        .status.error { background: rgba(244, 114, 182, 0.9); }

        .loading {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95);
            z-index: 999;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .spinner {
            width: 60px; height: 60px;
            border: 4px solid rgba(129, 140, 248, 0.3);
            border-top: 4px solid #818cf8;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .hidden { display: none !important; }
        
        .info-box {
            background: rgba(251, 191, 36, 0.1);
            border: 1px solid #fbbf24;
            color: #fbbf24;
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1rem;
            text-align: center;
        }

        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 0.5rem;
        }

        .switch {
            position: relative;
            width: 50px; height: 26px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #475569;
            transition: .4s;
            border-radius: 34px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px; width: 20px;
            left: 3px; bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider { background: linear-gradient(135deg, #818cf8, #c084fc); }
        input:checked + .slider:before { transform: translateX(24px); }

        .stem-btn {
            width: 100%;
            padding: 1rem;
            margin-bottom: 0.5rem;
            background: rgba(129, 140, 248, 0.2);
            border: 2px solid #818cf8;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .stem-btn:hover { background: linear-gradient(135deg, #818cf8, #c084fc); border-color: transparent; }

        .drop-zone-small {
            border: 2px dashed #818cf8;
            border-radius: 10px;
            padding: 1.5rem;
            text-align: center;
            cursor: pointer;
            margin-top: 1rem;
            background: rgba(129, 140, 248, 0.1);
        }
        .drop-zone-small:hover { background: rgba(129, 140, 248, 0.2); }
    </style>
<base target="_blank">
</head>
<body>

<div class="loading" id="loading">
    <div class="spinner"></div>
    <div style="margin-top: 1rem; color: #e0e7ff;">Processing...</div>
</div>

<div class="status" id="status"></div>

<div class="container">
    <header>
        <h1>üéôÔ∏è AI Vocal Studio Pro</h1>
        <p style="color: #a5b4fc;">Click Play to hear effects in real-time</p>
    </header>

    <div class="tabs hidden" id="tabs">
        <button class="tab active" onclick="switchTab('clean', event)">üßπ Clean & Edit</button>
        <button class="tab" onclick="switchTab('stems', event)">üéõÔ∏è Extract Stems</button>
        <button class="tab" onclick="switchTab('mix', event)">üéµ Mix with Beats</button>
    </div>

    <div class="upload-zone" id="mainUpload">
        <div style="font-size: 3rem; margin-bottom: 1rem;">‚òÅÔ∏è</div>
        <div style="font-size: 1.3rem; margin-bottom: 0.5rem;">Drop your vocals here or click to upload</div>
        <div style="color: #818cf8; font-size: 0.9rem;">WAV, MP3, M4A supported</div>
        <input type="file" id="fileInput" accept="audio/*">
    </div>

    <div class="editor-container" id="editor">
        
        <!-- CLEAN TAB -->
        <div id="cleanTab">
            <div class="info-box">
                üîä <strong>Live Preview:</strong> Click play, then adjust sliders to hear changes instantly!
            </div>

            <div style="text-align: center; margin-bottom: 1.5rem;">
                <button class="play-btn" id="playBtn" onclick="togglePlay()" disabled>‚ñ∂</button>
                <div style="margin-top: 0.5rem; color: #818cf8;" id="playStatus">Loading...</div>
            </div>

            <div class="waveform-container">
                <div id="waveform"></div>
            </div>

            <div class="controls-row">
                <div class="panel">
                    <h3>üîß Fix Issues</h3>
                    <div class="toggle-row">
                        <span>Noise Gate (Silence bg)</span>
                        <label class="switch">
                            <input type="checkbox" id="gate" onchange="updateChain()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="toggle-row">
                        <span>Compressor (Even volume)</span>
                        <label class="switch">
                            <input type="checkbox" id="compress" checked onchange="updateChain()">
                            <span class="slider"></span>
                        </label>
                    </div>
                    <div class="control" style="margin-top: 1rem;">
                        <label>High Pass Filter: <span id="hpDisp">100Hz</span></label>
                        <input type="range" id="highPass" min="40" max="300" value="100" oninput="updateChain(); document.getElementById('hpDisp').textContent = this.value + 'Hz'">
                    </div>
                </div>

                <div class="panel">
                    <h3>‚ú® Enhance Clarity</h3>
                    <div class="control">
                        <label>Presence (5kHz boost): <span id="prDisp">0dB</span></label>
                        <input type="range" id="presence" min="-12" max="15" value="0" oninput="updateChain(); document.getElementById('prDisp').textContent = this.value + 'dB'">
                    </div>
                    <div class="control">
                        <label>De-esser (Reduce harsh S sounds): <span id="dsDisp">0</span></label>
                        <input type="range" id="deesser" min="0" max="100" value="0" oninput="updateChain(); document.getElementById('dsDisp').textContent = this.value">
                    </div>
                    <div class="control">
                        <label>Output Volume: <span id="gainDisp">0dB</span></label>
                        <input type="range" id="gain" min="-20" max="20" value="0" oninput="updateChain(); document.getElementById('gainDisp').textContent = this.value + 'dB'">
                    </div>
                </div>

                <div class="panel">
                    <h3>üíæ Export Final</h3>
                    <p style="color: #a5b4fc; font-size: 0.9rem; margin-bottom: 1rem;">Render all effects to WAV file</p>
                    <button class="btn-success" onclick="exportAudio()" style="width: 100%; margin-bottom: 0.5rem;">Download Clean VOCALS</button>
                    <button class="btn-secondary" onclick="resetAudio()" style="width: 100%;">Reset to Original</button>
                </div>
            </div>
        </div>

        <!-- STEMS TAB -->
        <div id="stemsTab" class="hidden">
            <div class="panel" style="max-width: 600px; margin: 0 auto;">
                <h3>üéõÔ∏è AI Stem Separation</h3>
                <p style="color: #a5b4fc; margin-bottom: 1rem;">
                    Extract vocals or instrumental using stereo phase cancellation.<br>
                    <small>(Best for songs where vocals are centered)</small>
                </p>
                
                <button class="stem-btn" onclick="makeVocalStem()">üé§ Extract Vocals Only</button>
                <button class="stem-btn" onclick="makeInstStem()">üéπ Extract Instrumental (Karaoke)</button>
                
                <div id="stemPlayer" class="hidden" style="margin-top: 1.5rem;">
                    <div class="waveform-container">
                        <div id="stemWave"></div>
                    </div>
                    <div style="text-align: center; margin-top: 1rem;">
                        <button class="btn-primary" onclick="toggleStemPlay()" style="margin-right: 1rem;">‚ñ∂ Play Stem</button>
                        <button class="btn-success" onclick="exportStem()">üíæ Download Stem</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- MIX TAB -->
        <div id="mixTab" class="hidden">
            <div class="panel">
                <h3>üéµ Mix with Beat</h3>
                <div id="beatUploadBox" class="drop-zone-small">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem;">ü•Å</div>
                    <div>Drop a beat/instrumental here</div>
                    <input type="file" id="beatInput" accept="audio/*" style="display: none;">
                </div>
                
                <div id="mixControls" class="hidden" style="margin-top: 1.5rem;">
                    <div class="info-box">
                        Both tracks loaded! Adjust volumes and click Play to preview mix.
                    </div>
                    
                    <div class="controls-row">
                        <div class="panel">
                            <h3>üé§ Your Vocals</h3>
                            <div class="control">
                                <label>Volume: <span id="voxVolDisp">80%</span></label>
                                <input type="range" id="vocalVol" min="0" max="100" value="80" oninput="updateMix(); document.getElementById('voxVolDisp').textContent = this.value + '%'">
                            </div>
                        </div>
                        <div class="panel">
                            <h3>ü•Å Beat Track</h3>
                            <div class="control">
                                <label>Volume: <span id="beatVolDisp">70%</span></label>
                                <input type="range" id="beatVolSlider" min="0" max="100" value="70" oninput="updateMix(); document.getElementById('beatVolDisp').textContent = this.value + '%'">
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 1.5rem;">
                        <button class="play-btn" onclick="toggleMixPlay()" style="width: 70px; height: 70px;">‚ñ∂</button>
                        <button class="btn-success" onclick="exportMix()" style="margin-left: 1rem;">üíæ Export Mix</button>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

<script>
let wavesurfer;
let mainAudioUrl = null; // Track ObjectURL for cleanup
let audioCtx;
let sourceNode;
let gainNode, compNode, eqNode, hpNode, deesserNode, gateNode;
let originalBuffer;
let currentBuffer;
let isPlaying = false;
let startTime = 0;
let pauseTime = 0;

// Stem vars
let stemBuffer = null;
let stemWavesurfer = null;
let stemSource = null;
let isStemPlaying = false;

// Mix vars
let beatBuffer = null;
let vocalGain, beatGain;
let mixVocalSource, mixBeatSource;
let isMixPlaying = false;

// Initialize
document.getElementById('mainUpload').addEventListener('click', () => document.getElementById('fileInput').click());
document.getElementById('fileInput').addEventListener('change', handleUpload);

['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    document.getElementById('mainUpload').addEventListener(eventName, preventDefaults, false);
});

function preventDefaults(e) {
    e.preventDefault();
    e.stopPropagation();
}

document.getElementById('mainUpload').addEventListener('drop', handleDrop, false);

function handleDrop(e) {
    const dt = e.dataTransfer;
    const files = dt.files;
    handleFiles(files);
}

function handleUpload(e) {
    handleFiles(e.target.files);
}

async function handleFiles(files) {
    if (files.length === 0) return;
    const file = files[0];
    
    document.getElementById('loading').style.display = 'flex';
    document.getElementById('playBtn').disabled = true;
    document.getElementById('playStatus').textContent = 'Loading audio...';
    
    try {
        // Initialize audio context on user interaction
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        const arrayBuffer = await file.arrayBuffer();
        
        // FIX 6: Add error handling for audio decoding
        try {
            originalBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        } catch (decodeErr) {
            throw new Error('Failed to decode audio file. Please try a different format (WAV or MP3).');
        }
        
        currentBuffer = originalBuffer;
        
        // Cleanup previous URL if exists
        if (mainAudioUrl) {
            URL.revokeObjectURL(mainAudioUrl);
        }
        
        // Setup wavesurfer
        if (wavesurfer) wavesurfer.destroy();
        
        mainAudioUrl = URL.createObjectURL(file);
        wavesurfer = WaveSurfer.create({
            container: '#waveform',
            waveColor: '#818cf8',
            progressColor: '#c084fc',
            cursorColor: '#f472b6',
            barWidth: 2,
            height: 150,
            normalize: true
        });
        
        wavesurfer.load(mainAudioUrl);
        
        wavesurfer.on('ready', () => {
            document.getElementById('playBtn').disabled = false;
            document.getElementById('playStatus').textContent = 'Ready to play!';
        });
        
        // Show editor
        document.getElementById('mainUpload').style.display = 'none';
        document.getElementById('editor').style.display = 'block';
        document.getElementById('tabs').classList.remove('hidden');
        
        // Init audio nodes for live preview
        initAudioNodes();
        
        showStatus('Audio loaded! Click the play button to start.', 'success');
    } catch (err) {
        console.error(err);
        showStatus('Error: ' + err.message, 'error');
        document.getElementById('playStatus').textContent = 'Error loading audio';
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
}

function initAudioNodes() {
    // Create effect nodes
    gainNode = audioCtx.createGain();
    
    // FIX 4: Initialize Noise Gate
    gateNode = audioCtx.createDynamicsCompressor();
    gateNode.threshold.value = -60;
    gateNode.knee.value = 0;
    gateNode.ratio.value = 20;
    gateNode.attack.value = 0.001;
    gateNode.release.value = 0.1;
    
    compNode = audioCtx.createDynamicsCompressor();
    compNode.threshold.value = -24;
    compNode.knee.value = 30;
    compNode.ratio.value = 4;
    compNode.attack.value = 0.003;
    compNode.release.value = 0.1;
    
    hpNode = audioCtx.createBiquadFilter();
    hpNode.type = 'highpass';
    hpNode.frequency.value = 100;
    hpNode.Q.value = 1;
    
    eqNode = audioCtx.createBiquadFilter();
    eqNode.type = 'peaking';
    eqNode.frequency.value = 5000;
    eqNode.Q.value = 1;
    eqNode.gain.value = 0;
    
    deesserNode = audioCtx.createBiquadFilter();
    deesserNode.type = 'peaking';
    deesserNode.frequency.value = 8000;
    deesserNode.Q.value = 5;
    deesserNode.gain.value = 0;
}

async function resumeContext() {
    if (audioCtx && audioCtx.state === 'suspended') {
        await audioCtx.resume();
    }
}

// FIX 3: Removed audio restart logic - Web Audio nodes update in real-time
function updateChain() {
    if (!audioCtx) return;
    
    // Update values from UI
    const hpFreq = parseInt(document.getElementById('highPass').value);
    const presence = parseInt(document.getElementById('presence').value);
    const deesserAmt = parseInt(document.getElementById('deesser').value);
    const gainVal = parseInt(document.getElementById('gain').value);
    
    // Apply to nodes (these update in real-time without restarting source)
    hpNode.frequency.value = hpFreq;
    eqNode.gain.value = presence;
    deesserNode.gain.value = -(deesserAmt / 100 * 12);
    gainNode.gain.value = Math.pow(10, gainVal / 20);
}

async function togglePlay() {
    if (isPlaying) {
        stopAudio();
    } else {
        await resumeContext();
        playAudio();
    }
}

function playAudio() {
    if (!currentBuffer || !audioCtx) return;
    
    // Create new source
    sourceNode = audioCtx.createBufferSource();
    sourceNode.buffer = currentBuffer;
    
    // Build effect chain
    let lastNode = sourceNode;
    
    // 1. High Pass (always on, minimum processing)
    lastNode.connect(hpNode);
    lastNode = hpNode;
    
    // FIX 4: Add Noise Gate to chain
    if (document.getElementById('gate').checked) {
        lastNode.connect(gateNode);
        lastNode = gateNode;
    }
    
    // 2. Compressor
    if (document.getElementById('compress').checked) {
        lastNode.connect(compNode);
        lastNode = compNode;
    }
    
    // 3. EQ (Presence)
    if (parseInt(document.getElementById('presence').value) !== 0) {
        lastNode.connect(eqNode);
        lastNode = eqNode;
    }
    
    // 4. De-esser
    if (parseInt(document.getElementById('deesser').value) > 0) {
        lastNode.connect(deesserNode);
        lastNode = deesserNode;
    }
    
    // 5. Output Gain
    lastNode.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    // Start playback from pause position
    sourceNode.start(0, pauseTime);
    startTime = audioCtx.currentTime;
    
    // Update UI
    isPlaying = true;
    document.getElementById('playBtn').textContent = '‚è∏';
    document.getElementById('playStatus').textContent = 'Playing with live effects...';
    
    // Handle ended
    sourceNode.onended = () => {
        if (isPlaying) { // Natural end, not stopped manually
            isPlaying = false;
            pauseTime = 0;
            document.getElementById('playBtn').textContent = '‚ñ∂';
            document.getElementById('playStatus').textContent = 'Finished';
        }
    };
}

function stopAudio() {
    if (sourceNode) {
        try {
            sourceNode.stop();
            sourceNode.disconnect();
        } catch(e) {}
        sourceNode = null;
    }
    
    // Save position for resume
    if (isPlaying) {
        pauseTime = audioCtx.currentTime - startTime + pauseTime;
    }
    
    isPlaying = false;
    document.getElementById('playBtn').textContent = '‚ñ∂';
    document.getElementById('playStatus').textContent = 'Paused';
}

async function exportAudio() {
    if (!currentBuffer) return;
    
    document.getElementById('loading').style.display = 'flex';
    
    try {
        const offlineCtx = new OfflineAudioContext(
            currentBuffer.numberOfChannels,
            currentBuffer.length,
            currentBuffer.sampleRate
        );
        
        const source = offlineCtx.createBufferSource();
        source.buffer = currentBuffer;
        
        let lastNode = source;
        
        // Recreate chain in offline context
        const hp = offlineCtx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = parseInt(document.getElementById('highPass').value);
        lastNode.connect(hp);
        lastNode = hp;
        
        // FIX 4: Add Gate to export
        if (document.getElementById('gate').checked) {
            const gate = offlineCtx.createDynamicsCompressor();
            gate.threshold.value = -60;
            gate.knee.value = 0;
            gate.ratio.value = 20;
            gate.attack.value = 0.001;
            gate.release.value = 0.1;
            lastNode.connect(gate);
            lastNode = gate;
        }
        
        if (document.getElementById('compress').checked) {
            const comp = offlineCtx.createDynamicsCompressor();
            comp.threshold.value = -24;
            comp.ratio.value = 4;
            lastNode.connect(comp);
            lastNode = comp;
        }
        
        if (parseInt(document.getElementById('presence').value) !== 0) {
            const eq = offlineCtx.createBiquadFilter();
            eq.type = 'peaking';
            eq.frequency.value = 5000;
            eq.gain.value = parseInt(document.getElementById('presence').value);
            lastNode.connect(eq);
            lastNode = eq;
        }
        
        if (parseInt(document.getElementById('deesser').value) > 0) {
            const ds = offlineCtx.createBiquadFilter();
            ds.type = 'peaking';
            ds.frequency.value = 8000;
            ds.gain.value = -(parseInt(document.getElementById('deesser').value) / 100 * 12);
            lastNode.connect(ds);
            lastNode = ds;
        }
        
        const gain = offlineCtx.createGain();
        gain.gain.value = Math.pow(10, parseInt(document.getElementById('gain').value) / 20);
        lastNode.connect(gain);
        gain.connect(offlineCtx.destination);
        
        source.start();
        const rendered = await offlineCtx.startRendering();
        
        downloadBuffer(rendered, 'cleaned_vocals.wav');
        showStatus('Downloaded!', 'success');
    } catch (err) {
        showStatus('Export failed: ' + err.message, 'error');
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
}

function downloadBuffer(buffer, filename) {
    const wav = bufferToWave(buffer);
    const blob = new Blob([wav], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }, 100);
}

function bufferToWave(abuffer) {
    const numOfChan = abuffer.numberOfChannels;
    const length = abuffer.length * numOfChan * 2 + 44;
    const buffer = new ArrayBuffer(length);
    const view = new DataView(buffer);
    const channels = [];
    let offset = 0;
    let pos = 0;

    // Write header
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + abuffer.length * numOfChan * 2, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, numOfChan, true);
    view.setUint32(24, abuffer.sampleRate, true);
    view.setUint32(28, abuffer.sampleRate * numOfChan * 2, true);
    view.setUint16(32, numOfChan * 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, 'data');
    view.setUint32(40, abuffer.length * numOfChan * 2, true);

    for (let i = 0; i < numOfChan; i++) {
        channels.push(abuffer.getChannelData(i));
    }

    offset = 44;
    while (pos < abuffer.length) {
        for (let i = 0; i < numOfChan; i++) {
            let sample = Math.max(-1, Math.min(1, channels[i][pos]));
            sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
            view.setInt16(offset, sample, true);
            offset += 2;
        }
        pos++;
    }

    return buffer;
}

function writeString(view, offset, string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

function resetAudio() {
    currentBuffer = originalBuffer;
    pauseTime = 0;
    
    // Reset UI controls
    document.getElementById('highPass').value = 100;
    document.getElementById('presence').value = 0;
    document.getElementById('deesser').value = 0;
    document.getElementById('gain').value = 0;
    document.getElementById('gate').checked = false;
    document.getElementById('compress').checked = true;
    
    // Update displays
    document.getElementById('hpDisp').textContent = '100Hz';
    document.getElementById('prDisp').textContent = '0dB';
    document.getElementById('dsDisp').textContent = '0';
    document.getElementById('gainDisp').textContent = '0dB';
    
    updateChain();
    
    if (wavesurfer) {
        const wav = bufferToWave(originalBuffer);
        const blob = new Blob([wav], { type: 'audio/wav' });
        wavesurfer.loadBlob(blob);
    }
    
    showStatus('Reset to original', 'success');
}

// STEM FUNCTIONS
async function makeVocalStem() {
    if (!originalBuffer) return;
    document.getElementById('loading').style.display = 'flex';
    
    try {
        await resumeContext();
        const length = originalBuffer.length;
        const sampleRate = originalBuffer.sampleRate;
        
        // Center channel extraction (L + R) / 2
        const newBuffer = audioCtx.createBuffer(1, length, sampleRate);
        const left = originalBuffer.getChannelData(0);
        const right = originalBuffer.numberOfChannels > 1 ? originalBuffer.getChannelData(1) : left;
        const out = newBuffer.getChannelData(0);
        
        for (let i = 0; i < length; i++) {
            out[i] = (left[i] + right[i]) * 0.5;
        }
        
        stemBuffer = newBuffer;
        setupStemPlayer();
        showStatus('Vocals extracted! These are "center channel" vocals.', 'success');
    } catch (err) {
        showStatus('Error: ' + err.message, 'error');
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
}

async function makeInstStem() {
    if (!originalBuffer) return;
    document.getElementById('loading').style.display = 'flex';
    
    try {
        await resumeContext();
        const length = originalBuffer.length;
        const sampleRate = originalBuffer.sampleRate;
        
        // Karaoke: Side channels (L - R)
        const newBuffer = audioCtx.createBuffer(2, length, sampleRate);
        const left = originalBuffer.getChannelData(0);
        const right = originalBuffer.numberOfChannels > 1 ? originalBuffer.getChannelData(1) : left;
        const outLeft = newBuffer.getChannelData(0);
        const outRight = newBuffer.getChannelData(1);
        
        for (let i = 0; i < length; i++) {
            const side = (left[i] - right[i]) * 0.5;
            outLeft[i] = side;
            outRight[i] = side;
        }
        
        stemBuffer = newBuffer;
        setupStemPlayer();
        showStatus('Instrumental extracted! (Karaoke version)', 'success');
    } catch (err) {
        showStatus('Error: ' + err.message, 'error');
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
}

function setupStemPlayer() {
    document.getElementById('stemPlayer').classList.remove('hidden');
    
    if (stemWavesurfer) stemWavesurfer.destroy();
    stemWavesurfer = WaveSurfer.create({
        container: '#stemWave',
        waveColor: '#34d399',
        progressColor: '#10b981',
        barWidth: 2,
        height: 100
    });
    
    const wav = bufferToWave(stemBuffer);
    const blob = new Blob([wav], { type: 'audio/wav' });
    stemWavesurfer.loadBlob(blob);
}

async function toggleStemPlay() {
    if (isStemPlaying) {
        if (stemSource) {
            try { stemSource.stop(); } catch(e) {}
            stemSource = null;
        }
        isStemPlaying = false;
    } else {
        if (!stemBuffer) return;
        await resumeContext();
        
        stemSource = audioCtx.createBufferSource();
        stemSource.buffer = stemBuffer;
        stemSource.connect(audioCtx.destination);
        stemSource.start();
        isStemPlaying = true;
        
        stemSource.onended = () => {
            isStemPlaying = false;
        };
    }
}

function exportStem() {
    if (!stemBuffer) return;
    downloadBuffer(stemBuffer, 'extracted_stem.wav');
    showStatus('Stem downloaded!', 'success');
}

// MIX FUNCTIONS
document.getElementById('beatUploadBox').addEventListener('click', () => document.getElementById('beatInput').click());
document.getElementById('beatInput').addEventListener('change', async (e) => {
    if (!e.target.files[0]) return;
    document.getElementById('loading').style.display = 'flex';
    
    try {
        await resumeContext();
        const arrayBuffer = await e.target.files[0].arrayBuffer();
        beatBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        document.getElementById('mixControls').classList.remove('hidden');
        document.getElementById('beatUploadBox').style.display = 'none';
        showStatus('Beat loaded! Adjust volumes and mix.', 'success');
    } catch (err) {
        showStatus('Error loading beat: ' + err.message, 'error');
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
});

function updateMix() {
    if (vocalGain) vocalGain.gain.value = document.getElementById('vocalVol').value / 100;
    if (beatGain) beatGain.gain.value = document.getElementById('beatVolSlider').value / 100;
}

async function toggleMixPlay() {
    if (isMixPlaying) {
        stopMix();
    } else {
        await resumeContext();
        playMix();
    }
}

function playMix() {
    if (!currentBuffer || !beatBuffer) {
        showStatus('Need both vocals and beat!', 'error');
        return;
    }
    
    stopMix(); // Ensure clean state
    
    // Create sources
    mixVocalSource = audioCtx.createBufferSource();
    mixVocalSource.buffer = currentBuffer;
    
    mixBeatSource = audioCtx.createBufferSource();
    mixBeatSource.buffer = beatBuffer;
    
    // Create gains
    vocalGain = audioCtx.createGain();
    beatGain = audioCtx.createGain();
    vocalGain.gain.value = document.getElementById('vocalVol').value / 100;
    beatGain.gain.value = document.getElementById('beatVolSlider').value / 100;
    
    // Connect
    mixVocalSource.connect(vocalGain);
    mixBeatSource.connect(beatGain);
    vocalGain.connect(audioCtx.destination);
    beatGain.connect(audioCtx.destination);
    
    // Start together
    const when = audioCtx.currentTime + 0.1;
    mixVocalSource.start(when);
    mixBeatSource.start(when);
    
    isMixPlaying = true;
    
    mixVocalSource.onended = () => { isMixPlaying = false; };
}

function stopMix() {
    if (mixVocalSource) {
        try { mixVocalSource.stop(); } catch(e) {}
        mixVocalSource = null;
    }
    if (mixBeatSource) {
        try { mixBeatSource.stop(); } catch(e) {}
        mixBeatSource = null;
    }
    isMixPlaying = false;
}

async function exportMix() {
    if (!currentBuffer || !beatBuffer) return;
    
    document.getElementById('loading').style.display = 'flex';
    
    try {
        const maxLength = Math.max(currentBuffer.length, beatBuffer.length);
        const sampleRate = currentBuffer.sampleRate;
        
        const offlineCtx = new OfflineAudioContext(2, maxLength, sampleRate);
        
        // Vocal chain
        const vSource = offlineCtx.createBufferSource();
        vSource.buffer = currentBuffer;
        const vGain = offlineCtx.createGain();
        vGain.gain.value = document.getElementById('vocalVol').value / 100;
        vSource.connect(vGain);
        vGain.connect(offlineCtx.destination);
        
        // Beat chain
        const bSource = offlineCtx.createBufferSource();
        bSource.buffer = beatBuffer;
        const bGain = offlineCtx.createGain();
        bGain.gain.value = document.getElementById('beatVolSlider').value / 100;
        bSource.connect(bGain);
        bGain.connect(offlineCtx.destination);
        
        vSource.start();
        bSource.start();
        
        const rendered = await offlineCtx.startRendering();
        downloadBuffer(rendered, 'mixed_song.wav');
        showStatus('Mixed track downloaded!', 'success');
    } catch (err) {
        showStatus('Mix failed: ' + err.message, 'error');
    } finally {
        document.getElementById('loading').style.display = 'none';
    }
}

// UI Helpers
// FIX 2: Properly pass and use event parameter
function switchTab(tab, evt) {
    // Stop all playback
    stopAudio();
    stopMix();
    if (isStemPlaying) toggleStemPlay();
    
    // Update UI
    document.querySelectorAll('.tab').forEach(btn => btn.classList.remove('active'));
    evt.target.classList.add('active');
    
    document.getElementById('cleanTab').classList.add('hidden');
    document.getElementById('stemsTab').classList.add('hidden');
    document.getElementById('mixTab').classList.add('hidden');
    
    document.getElementById(tab + 'Tab').classList.remove('hidden');
}

function showStatus(msg, type) {
    const status = document.getElementById('status');
    status.textContent = msg;
    status.className = 'status show ' + type;
    setTimeout(() => status.classList.remove('show'), 4000);
}

// Handle page visibility change (pause when switching tabs)
document.addEventListener('visibilitychange', () => {
    if (document.hidden && isPlaying) {
        stopAudio();
    }
});
</script>

</body>
</html>
