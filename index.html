<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI DAW Pro - Professional Music Production</title>
    <script src="https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; }
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #151520;
            --bg-track: #1a1a2e;
            --accent: #6366f1;
            --accent-hover: #818cf8;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --border: #2d3748;
            --record: #ef4444;
            --play: #10b981;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header & Transport */
        .header {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 60px;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(135deg, #818cf8, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .transport {
            display: flex;
            align-items: center;
            gap: 1rem;
            background: rgba(0,0,0,0.3);
            padding: 0.25rem 1rem;
            border-radius: 30px;
            border: 1px solid var(--border);
        }

        .transport-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: all 0.2s;
            background: var(--bg-track);
            color: var(--text);
        }

        .transport-btn:hover { transform: scale(1.1); }
        .transport-btn.record { color: var(--record); border: 2px solid var(--record); }
        .transport-btn.record.active { background: var(--record); color: white; }
        .transport-btn.play { color: var(--play); border: 2px solid var(--play); }
        .transport-btn.play.active { background: var(--play); color: white; }

        .time-display {
            font-family: monospace;
            font-size: 1.5rem;
            color: var(--accent);
            min-width: 100px;
            text-align: center;
        }

        .bpm-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .bpm-control input {
            width: 60px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.25rem;
            border-radius: 4px;
            text-align: center;
        }

        /* Main Layout */
        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            padding: 0.5rem;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 0.5rem 1rem;
            background: var(--bg-track);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tool-btn:hover { background: var(--accent); border-color: var(--accent); }
        .tool-btn.active { background: var(--accent); box-shadow: 0 0 10px rgba(99, 102, 241, 0.5); }

        /* Track Headers (Left Side) */
        .track-panel {
            width: 250px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-header {
            padding: 1rem;
            background: rgba(0,0,0,0.2);
            border-bottom: 1px solid var(--border);
            font-weight: bold;
            color: var(--accent);
        }

        .track-header {
            height: 100px;
            background: var(--bg-track);
            border-bottom: 1px solid var(--border);
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            position: relative;
        }

        .track-header.active { background: rgba(99, 102, 241, 0.1); border-left: 3px solid var(--accent); }
        
        .track-name {
            font-weight: 600;
            color: var(--text);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .track-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .track-btn {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            border: 1px solid var(--border);
            background: var(--bg-dark);
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .track-btn.mute.active { background: #ef4444; color: white; border-color: #ef4444; }
        .track-btn.solo.active { background: #f59e0b; color: white; border-color: #f59e0b; }
        .track-btn.arm.active { background: var(--record); color: white; border-color: var(--record); }

        .fader-container {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: auto;
        }

        .fader {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            background: var(--bg-dark);
            border-radius: 3px;
            outline: none;
        }

        .fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
        }

        .pan-knob {
            width: 40px;
            text-align: center;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.2rem;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        /* Timeline Area */
        .timeline-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-dark);
        }

        .timeline-ruler {
            height: 30px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .timeline-tracks {
            flex: 1;
            overflow: auto;
            position: relative;
        }

        .timeline-track {
            height: 100px;
            border-bottom: 1px solid var(--border);
            background: rgba(26, 26, 46, 0.5);
            position: relative;
            overflow: hidden;
        }

        .timeline-track:nth-child(even) { background: rgba(26, 26, 46, 0.3); }

        .clip {
            position: absolute;
            height: 80px;
            top: 10px;
            background: linear-gradient(135deg, var(--accent), #8b5cf6);
            border-radius: 4px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8rem;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid transparent;
        }

        .clip.selected { border-color: white; box-shadow: 0 0 0 2px var(--accent); }
        .clip .waveform-mini { width: 100%; height: 100%; opacity: 0.3; }
        .clip-name { position: absolute; z-index: 2; text-shadow: 0 1px 2px rgba(0,0,0,0.8); }

        .playhead {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: var(--record);
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 10px var(--record);
        }

        .selection-rect {
            position: absolute;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid var(--accent);
            pointer-events: none;
            z-index: 999;
        }

        /* Bottom Panels */
        .bottom-panels {
            height: 300px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
        }

        .panel-tabs {
            width: 120px;
            background: var(--bg-dark);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .panel-tab {
            padding: 1rem;
            cursor: pointer;
            border-bottom: 1px solid var(--border);
            color: var(--text-muted);
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .panel-tab:hover { background: rgba(255,255,255,0.05); color: var(--text); }
        .panel-tab.active { background: var(--accent); color: white; }

        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 1rem;
        }

        /* Piano Roll */
        .piano-roll {
            display: none;
            height: 100%;
        }

        .piano-roll.active { display: flex; }

        .piano-keys {
            width: 60px;
            background: var(--bg-dark);
            border-right: 1px solid var(--border);
            overflow-y: scroll;
        }

        .piano-key {
            height: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding-left: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .piano-key.black {
            background: #0f0f1a;
            color: #64748b;
        }

        .piano-grid {
            flex: 1;
            position: relative;
            overflow: auto;
            background-image: 
                linear-gradient(to right, var(--border) 1px, transparent 1px),
                linear-gradient(to bottom, var(--border) 1px, transparent 1px);
            background-size: 40px 20px;
        }

        .midi-note {
            position: absolute;
            background: var(--accent);
            border-radius: 2px;
            cursor: move;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .midi-note.selected { background: #f59e0b; }

        /* Mixer */
        .mixer-view {
            display: none;
            height: 100%;
            gap: 1rem;
            overflow-x: auto;
        }

        .mixer-view.active { display: flex; }

        .mixer-channel {
            width: 80px;
            background: var(--bg-track);
            border-radius: 8px;
            padding: 0.75rem 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .mixer-label {
            font-size: 0.75rem;
            color: var(--text-muted);
            writing-mode: vertical-rl;
            text-orientation: mixed;
            height: 80px;
            display: flex;
            align-items: center;
        }

        .meter {
            width: 8px;
            height: 150px;
            background: var(--bg-dark);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .meter-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #10b981 0%, #f59e0b 70%, #ef4444 100%);
            transition: height 0.05s;
        }

        .vertical-fader {
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            width: 30px;
            height: 150px;
        }

        /* AI Panel */
        .ai-panel { display: none; }
        .ai-panel.active { display: block; }

        .ai-section {
            background: var(--bg-track);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            border: 1px solid var(--border);
        }

        .ai-section h3 {
            color: var(--accent);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .ai-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .ai-card {
            background: var(--bg-dark);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .ai-card:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.2);
        }

        .ai-card h4 { color: var(--text); margin-bottom: 0.5rem; }
        .ai-card p { color: var(--text-muted); font-size: 0.85rem; }

        /* Effects Rack */
        .effects-rack { display: none; }
        .effects-rack.active { display: block; }

        .effect-slot {
            background: var(--bg-track);
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 0.5rem;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s;
        }

        .effect-slot:hover { border-color: var(--accent); color: var(--accent); }
        .effect-slot.occupied {
            border-style: solid;
            border-color: var(--accent);
            background: rgba(99, 102, 241, 0.1);
            justify-content: space-between;
        }

        .effect-param {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .effect-param label {
            width: 100px;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        /* Loop Library */
        .loop-library {
            display: none;
            height: 100%;
            overflow-y: auto;
        }

        .loop-library.active { display: block; }

        .loop-category {
            margin-bottom: 1rem;
        }

        .loop-category h4 {
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .loop-item {
            background: var(--bg-track);
            padding: 0.75rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
            transition: all 0.2s;
        }

        .loop-item:hover {
            background: rgba(99, 102, 241, 0.1);
            border-color: var(--accent);
        }

        .loop-item button {
            background: var(--accent);
            color: white;
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
        }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .modal.active { display: flex; }

        .modal-content {
            background: var(--bg-panel);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        select, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 6px;
            margin-bottom: 1rem;
        }

        .modal-actions {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-secondary {
            background: var(--bg-track);
            color: var(--text);
            border: 1px solid var(--border);
        }

        /* Scrollbars */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-dark); }
        ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

        /* Hidden file input */
        input[type="file"] { display: none; }
    </style>
</head>
<body>

<div class="header">
    <div class="logo">üéπ AI DAW Pro</div>
    
    <div class="transport">
        <button class="transport-btn" id="stopBtn" onclick="transportStop()">‚èπ</button>
        <button class="transport-btn record" id="recordBtn" onclick="toggleRecord()">‚è∫</button>
        <button class="transport-btn play" id="playBtn" onclick="togglePlay()">‚ñ∂</button>
        <div class="time-display" id="timeDisplay">00:00:00</div>
    </div>
    
    <div class="bpm-control">
        <label>BPM:</label>
        <input type="number" id="bpmInput" value="120" min="60" max="200" onchange="updateBPM(this.value)">
    </div>
</div>

<div class="toolbar">
    <button class="tool-btn" onclick="addAudioTrack()">
        <span>üéµ</span> Add Audio Track
    </button>
    <button class="tool-btn" onclick="addMidiTrack()">
        <span>üéπ</span> Add MIDI Track
    </button>
    <button class="tool-btn" onclick="document.getElementById('fileInput').click()">
        <span>üìÅ</span> Import Audio
    </button>
    <button class="tool-btn" onclick="splitAtPlayhead()">
        <span>‚úÇÔ∏è</span> Split
    </button>
    <button class="tool-btn" onclick="deleteSelection()">
        <span>üóëÔ∏è</span> Delete
    </button>
    <button class="tool-btn" onclick="duplicateSelection()">
        <span>üìã</span> Duplicate
    </button>
    <button class="tool-btn" onclick="showAIModal()">
        <span>ü§ñ</span> AI Generate
    </button>
    <input type="file" id="fileInput" accept="audio/*" onchange="importAudio(event)">
</div>

<div class="main-container">
    <!-- Track Headers -->
    <div class="track-panel" id="trackPanel">
        <div class="panel-header">Tracks</div>
        <div id="trackHeaders"></div>
    </div>

    <!-- Timeline -->
    <div class="timeline-container">
        <div class="timeline-ruler" id="timelineRuler"></div>
        <div class="timeline-tracks" id="timelineTracks" onmousedown="startSelection(event)">
            <div class="playhead" id="playhead" style="left: 0px;"></div>
            <div id="trackLanes"></div>
            <div class="selection-rect" id="selectionRect" style="display: none;"></div>
        </div>
    </div>
</div>

<!-- Bottom Panels -->
<div class="bottom-panels">
    <div class="panel-tabs">
        <div class="panel-tab active" onclick="switchPanel('piano')">üéπ Piano</div>
        <div class="panel-tab" onclick="switchPanel('mixer')">üéõÔ∏è Mixer</div>
        <div class="panel-tab" onclick="switchPanel('effects')">‚ö° Effects</div>
        <div class="panel-tab" onclick="switchPanel('loops')">üîÑ Loops</div>
        <div class="panel-tab" onclick="switchPanel('ai')">ü§ñ AI Tools</div>
    </div>
    
    <div class="panel-content">
        <!-- Piano Roll -->
        <div class="piano-roll active" id="pianoPanel">
            <div class="piano-keys" id="pianoKeys"></div>
            <div class="piano-grid" id="pianoGrid" onmousedown="addMidiNote(event)"></div>
        </div>
        
        <!-- Mixer -->
        <div class="mixer-view" id="mixerPanel"></div>
        
        <!-- Effects -->
        <div class="effects-rack" id="effectsPanel">
            <h3 style="margin-bottom: 1rem; color: var(--accent);">Track Effects Chain</h3>
            <div id="effectsChain"></div>
        </div>
        
        <!-- Loop Library -->
        <div class="loop-library" id="loopsPanel">
            <div class="loop-category">
                <h4>Drums</h4>
                <div class="loop-item">
                    <span>Trap Beat 140BPM</span>
                    <button onclick="addLoop('trap')">Add</button>
                </div>
                <div class="loop-item">
                    <span>Lo-Fi Hip Hop</span>
                    <button onclick="addLoop('lofi')">Add</button>
                </div>
            </div>
            <div class="loop-category">
                <h4>Melodies</h4>
                <div class="loop-item">
                    <span>Synth Arp C Major</span>
                    <button onclick="addLoop('arp')">Add</button>
                </div>
                <div class="loop-item">
                    <span>Piano Chords</span>
                    <button onclick="addLoop('piano')">Add</button>
                </div>
            </div>
        </div>
        
        <!-- AI Panel -->
        <div class="ai-panel" id="aiPanel">
            <div class="ai-grid">
                <div class="ai-card" onclick="generateMelody()">
                    <h4>üéµ Generate Melody</h4>
                    <p>AI creates a melody based on selected scale and mood</p>
                </div>
                <div class="ai-card" onclick="generateChords()">
                    <h4>üéπ Generate Chords</h4>
                    <p>Smart chord progression generator</p>
                </div>
                <div class="ai-card" onclick="smartMaster()">
                    <h4>‚ú® Smart Master</h4>
                    <p>Auto-mix and master your track</p>
                </div>
                <div class="ai-card" onclick="removeSilence()">
                    <h4>üîá Remove Silence</h4>
                    <p>Automatically trim silent sections</p>
                </div>
                <div class="ai-card" onclick="styleTransfer()">
                    <h4>üé® Style Transfer</h4>
                    <p>Apply style from reference track</p>
                </div>
                <div class="ai-card" onclick="quantizeAudio()">
                    <h4>‚ö° Quantize</h4>
                    <p>Auto-align notes to grid</p>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- AI Generation Modal -->
<div class="modal" id="aiModal">
    <div class="modal-content">
        <div class="modal-header">AI Music Generator</div>
        <label>Style:</label>
        <select id="aiStyle">
            <option value="pop">Pop</option>
            <option value="rock">Rock</option>
            <option value="electronic">Electronic</option>
            <option value="jazz">Jazz</option>
            <option value="lofi">Lo-Fi</option>
        </select>
        
        <label>Duration (bars):</label>
        <input type="number" id="aiDuration" value="8" min="4" max="32">
        
        <div class="modal-actions">
            <button class="btn btn-secondary" onclick="closeAIModal()">Cancel</button>
            <button class="btn btn-primary" onclick="generateAIMusic()">Generate</button>
        </div>
    </div>
</div>

<script>
// Global State
let tracks = [];
let currentTrack = 0;
let isPlaying = false;
let isRecording = false;
let currentTime = 0;
let bpm = 120;
let pixelsPerSecond = 50;
let animationFrame;
let audioCtx;
let playheadInterval;
let selectedClips = new Set();
let isSelecting = false;
let selectionStart = { x: 0, y: 0 };

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    initAudioContext();
    createPianoKeys();
    addAudioTrack(); // Create first track by default
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
            e.preventDefault();
            togglePlay();
        } else if (e.code === 'Delete' || e.code === 'Backspace') {
            deleteSelection();
        }
    });
});

function initAudioContext() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

// Track Management
class Track {
    constructor(type = 'audio') {
        this.id = tracks.length;
        this.type = type;
        this.name = `Track ${this.id + 1}`;
        this.clips = [];
        this.volume = 0.8;
        this.pan = 0;
        this.mute = false;
        this.solo = false;
        this.arm = false;
        this.effects = [];
        this.midiNotes = [];
        
        // Audio Graph Nodes
        this.gainNode = audioCtx.createGain();
        this.pannerNode = audioCtx.createStereoPanner();
        this.analyser = audioCtx.createAnalyser();
        
        this.gainNode.connect(this.pannerNode);
        this.pannerNode.connect(this.analyser);
        this.analyser.connect(audioCtx.destination);
        
        this.createDOM();
    }
    
    createDOM() {
        // Create Header
        const header = document.createElement('div');
        header.className = 'track-header' + (this.id === currentTrack ? ' active' : '');
        header.innerHTML = `
            <div class="track-name">
                ${this.type === 'audio' ? 'üéµ' : 'üéπ'} ${this.name}
                <span style="font-size: 0.75rem; color: var(--text-muted);">${this.type.toUpperCase()}</span>
            </div>
            <div class="track-controls">
                <button class="track-btn mute ${this.mute ? 'active' : ''}" onclick="toggleMute(${this.id})">M</button>
                <button class="track-btn solo ${this.solo ? 'active' : ''}" onclick="toggleSolo(${this.id})">S</button>
                <button class="track-btn arm ${this.arm ? 'active' : ''}" onclick="toggleArm(${this.id})">‚è∫</button>
            </div>
            <div class="fader-container">
                <span style="font-size: 0.75rem;">L</span>
                <input type="range" class="fader" min="-1" max="1" step="0.1" value="0" oninput="updatePan(${this.id}, this.value)">
                <span style="font-size: 0.75rem;">R</span>
                <input type="range" class="fader" min="0" max="1" step="0.01" value="0.8" oninput="updateVolume(${this.id}, this.value)" style="flex: 2;">
            </div>
        `;
        header.onclick = () => selectTrack(this.id);
        document.getElementById('trackHeaders').appendChild(header);
        
        // Create Timeline Lane
        const lane = document.createElement('div');
        lane.className = 'timeline-track';
        lane.id = `lane-${this.id}`;
        lane.ondrop = (e) => handleDrop(e, this.id);
        lane.ondragover = (e) => e.preventDefault();
        document.getElementById('trackLanes').appendChild(lane);
        
        // Add to mixer
        this.createMixerChannel();
    }
    
    createMixerChannel() {
        const channel = document.createElement('div');
        channel.className = 'mixer-channel';
        channel.id = `mixer-${this.id}`;
        channel.innerHTML = `
            <div class="track-btn mute ${this.mute ? 'active' : ''}" onclick="toggleMute(${this.id})">M</div>
            <div class="track-btn solo ${this.solo ? 'active' : ''}" onclick="toggleSolo(${this.id})">S</div>
            <div class="meter">
                <div class="meter-fill" id="meter-${this.id}" style="height: 0%"></div>
            </div>
            <input type="range" class="vertical-fader" min="0" max="1" step="0.01" value="0.8" orient="vertical" oninput="updateVolume(${this.id}, this.value)">
            <div class="mixer-label">${this.name}</div>
        `;
        document.getElementById('mixerPanel').appendChild(channel);
    }
}

// Track Controls
function addAudioTrack() {
    tracks.push(new Track('audio'));
    updateEffectsPanel();
}

function addMidiTrack() {
    tracks.push(new Track('midi'));
    updateEffectsPanel();
}

function selectTrack(id) {
    currentTrack = id;
    document.querySelectorAll('.track-header').forEach((h, i) => {
        h.classList.toggle('active', i === id);
    });
    updateEffectsPanel();
}

function toggleMute(id) {
    tracks[id].mute = !tracks[id].mute;
    tracks[id].gainNode.gain.value = tracks[id].mute ? 0 : tracks[id].volume;
    document.querySelectorAll(`.track-btn.mute`).forEach((btn, i) => {
        if (tracks[i]) btn.classList.toggle('active', tracks[i].mute);
    });
    updateMixerButtons(id);
}

function toggleSolo(id) {
    tracks[id].solo = !tracks[id].solo;
    updateMixerButtons(id);
    
    // Apply solo logic
    const anySolo = tracks.some(t => t.solo);
    tracks.forEach((track, i) => {
        if (anySolo) {
            track.gainNode.gain.value = track.solo ? track.volume : 0;
        } else {
            track.gainNode.gain.value = track.mute ? 0 : track.volume;
        }
    });
}

function toggleArm(id) {
    tracks[id].arm = !tracks[id].arm;
    document.querySelectorAll('.track-btn.arm').forEach((btn, i) => {
        if (tracks[i]) btn.classList.toggle('active', tracks[i].arm);
    });
    updateMixerButtons(id);
}

function updateMixerButtons(id) {
    const mixer = document.getElementById(`mixer-${id}`);
    if (mixer) {
        mixer.querySelector('.mute').classList.toggle('active', tracks[id].mute);
        mixer.querySelector('.solo').classList.toggle('active', tracks[id].solo);
    }
}

function updateVolume(id, val) {
    tracks[id].volume = parseFloat(val);
    if (!tracks[id].mute && !tracks.some(t => t.solo && t.id !== id)) {
        tracks[id].gainNode.gain.value = tracks[id].volume;
    }
}

function updatePan(id, val) {
    tracks[id].pan = parseFloat(val);
    tracks[id].pannerNode.pan.value = tracks[id].pan;
}

// Transport Controls
async function togglePlay() {
    if (isPlaying) {
        pauseTransport();
    } else {
        await startTransport();
    }
}

async function startTransport() {
    if (audioCtx.state === 'suspended') await audioCtx.resume();
    
    isPlaying = true;
    document.getElementById('playBtn').classList.add('active');
    document.getElementById('playBtn').innerHTML = '‚è∏';
    
    const startTime = audioCtx.currentTime;
    const startPos = currentTime;
    
    // Schedule all clips
    tracks.forEach(track => {
        track.clips.forEach(clip => {
            if (clip.buffer && clip.startTime >= startPos) {
                const source = audioCtx.createBufferSource();
                source.buffer = clip.buffer;
                source.connect(track.gainNode);
                
                const when = startTime + (clip.startTime - startPos);
                source.start(when);
                clip.source = source;
            }
        });
    });
    
    // Update playhead
    playheadInterval = setInterval(() => {
        const elapsed = audioCtx.currentTime - startTime;
        currentTime = startPos + elapsed;
        updatePlayhead();
        
        // Update meters
        updateMeters();
        
        // Loop or stop
        if (currentTime > 60) { // 1 minute max for demo
            transportStop();
        }
    }, 50);
}

function pauseTransport() {
    isPlaying = false;
    document.getElementById('playBtn').classList.remove('active');
    document.getElementById('playBtn').innerHTML = '‚ñ∂';
    
    clearInterval(playheadInterval);
    
    // Stop all sources
    tracks.forEach(track => {
        track.clips.forEach(clip => {
            if (clip.source) {
                try { clip.source.stop(); } catch(e) {}
                clip.source = null;
            }
        });
    });
}

function transportStop() {
    pauseTransport();
    currentTime = 0;
    updatePlayhead();
}

function toggleRecord() {
    isRecording = !isRecording;
    document.getElementById('recordBtn').classList.toggle('active', isRecording);
    
    if (isRecording && !isPlaying) {
        togglePlay();
        // Start recording logic here
        startRecording();
    }
}

async function startRecording() {
    const track = tracks.find(t => t.arm);
    if (!track) {
        alert('Please arm a track for recording first!');
        isRecording = false;
        document.getElementById('recordBtn').classList.remove('active');
        return;
    }
    
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mediaRecorder = new MediaRecorder(stream);
        const chunks = [];
        
        mediaRecorder.ondataavailable = e => chunks.push(e.data);
        mediaRecorder.onstop = async () => {
            const blob = new Blob(chunks, { type: 'audio/wav' });
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
            
            const clip = {
                id: Date.now(),
                buffer: audioBuffer,
                startTime: currentTime,
                duration: audioBuffer.duration,
                name: `Recording ${track.clips.length + 1}`
            };
            
            track.clips.push(clip);
            renderClip(clip, track.id);
        };
        
        mediaRecorder.start();
        
        // Stop when transport stops
        const checkStop = setInterval(() => {
            if (!isRecording) {
                mediaRecorder.stop();
                stream.getTracks().forEach(track => track.stop());
                clearInterval(checkStop);
            }
        }, 100);
        
    } catch (err) {
        alert('Microphone access denied or not available');
        isRecording = false;
    }
}

function updatePlayhead() {
    const pos = currentTime * pixelsPerSecond;
    document.getElementById('playhead').style.left = pos + 'px';
    
    // Scroll if necessary
    const container = document.querySelector('.timeline-tracks');
    if (pos > container.scrollLeft + container.clientWidth - 50) {
        container.scrollLeft = pos - 50;
    }
    
    // Update time display
    const mins = Math.floor(currentTime / 60).toString().padStart(2, '0');
    const secs = Math.floor(currentTime % 60).toString().padStart(2, '0');
    const ms = Math.floor((currentTime % 1) * 100).toString().padStart(2, '0');
    document.getElementById('timeDisplay').textContent = `${mins}:${secs}:${ms}`;
}

function updateBPM(value) {
    bpm = parseInt(value);
}

function updateMeters() {
    tracks.forEach((track, i) => {
        const dataArray = new Uint8Array(track.analyser.frequencyBinCount);
        track.analyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / dataArray.length;
        const height = Math.min(100, (average / 255) * 100);
        
        const meter = document.getElementById(`meter-${i}`);
        if (meter) meter.style.height = height + '%';
    });
}

// Clip Management
function importAudio(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        const arrayBuffer = e.target.result;
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        
        const clip = {
            id: Date.now(),
            buffer: audioBuffer,
            startTime: currentTime,
            duration: audioBuffer.duration,
            name: file.name.substring(0, 20)
        };
        
        tracks[currentTrack].clips.push(clip);
        renderClip(clip, currentTrack);
    };
    reader.readAsArrayBuffer(file);
}

function renderClip(clip, trackId) {
    const lane = document.getElementById(`lane-${trackId}`);
    const div = document.createElement('div');
    div.className = 'clip';
    div.id = `clip-${clip.id}`;
    div.style.left = (clip.startTime * pixelsPerSecond) + 'px';
    div.style.width = (clip.duration * pixelsPerSecond) + 'px';
    div.innerHTML = `<span class="clip-name">${clip.name}</span>`;
    
    // Draw waveform preview
    if (tracks[trackId].type === 'audio' && clip.buffer) {
        const canvas = document.createElement('canvas');
        canvas.className = 'waveform-mini';
        canvas.width = clip.duration * pixelsPerSecond;
        canvas.height = 80;
        drawWaveform(canvas, clip.buffer);
        div.appendChild(canvas);
    }
    
    div.onclick = (e) => {
        e.stopPropagation();
        selectClip(clip.id);
    };
    
    div.draggable = true;
    div.ondragstart = (e) => {
        e.dataTransfer.setData('clipId', clip.id);
        e.dataTransfer.setData('trackId', trackId);
    };
    
    lane.appendChild(div);
}

function drawWaveform(canvas, buffer) {
    const ctx = canvas.getContext('2d');
    const data = buffer.getChannelData(0);
    const step = Math.floor(data.length / canvas.width);
    
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    for (let i = 0; i < canvas.width; i++) {
        let min = 1.0;
        let max = -1.0;
        for (let j = 0; j < step; j++) {
            const datum = data[(i * step) + j];
            if (datum < min) min = datum;
            if (datum > max) max = datum;
        }
        const height = (max - min) * 40;
        ctx.fillRect(i, 40 + min * 40, 1, height);
    }
}

function selectClip(id) {
    document.querySelectorAll('.clip').forEach(c => c.classList.remove('selected'));
    selectedClips.clear();
    
    const clip = document.getElementById(`clip-${id}`);
    if (clip) {
        clip.classList.add('selected');
        selectedClips.add(id);
    }
}

function handleDrop(e, trackId) {
    e.preventDefault();
    const clipId = parseInt(e.dataTransfer.getData('clipId'));
    const fromTrackId = parseInt(e.dataTransfer.getData('trackId'));
    
    if (fromTrackId === trackId) return;
    
    // Move clip between tracks
    const clip = tracks[fromTrackId].clips.find(c => c.id === clipId);
    if (clip) {
        tracks[fromTrackId].clips = tracks[fromTrackId].clips.filter(c => c.id !== clipId);
        tracks[trackId].clips.push(clip);
        
        // Re-render
        refreshTimeline();
    }
}

function refreshTimeline() {
    document.getElementById('trackLanes').innerHTML = '';
    tracks.forEach((track, i) => {
        const lane = document.createElement('div');
        lane.className = 'timeline-track';
        lane.id = `lane-${i}`;
        lane.ondrop = (e) => handleDrop(e, i);
        lane.ondragover = (e) => e.preventDefault();
        document.getElementById('trackLanes').appendChild(lane);
        
        track.clips.forEach(clip => renderClip(clip, i));
    });
}

// Editing Functions
function startSelection(e) {
    if (e.target.classList.contains('clip')) return;
    
    isSelecting = true;
    const rect = document.getElementById('timelineTracks').getBoundingClientRect();
    selectionStart.x = e.clientX - rect.left + document.getElementById('timelineTracks').scrollLeft;
    selectionStart.y = e.clientY - rect.top;
    
    const selRect = document.getElementById('selectionRect');
    selRect.style.display = 'block';
    selRect.style.left = selectionStart.x + 'px';
    selRect.style.top = selectionStart.y + 'px';
    selRect.style.width = '0px';
    selRect.style.height = '0px';
    
    document.addEventListener('mousemove', updateSelection);
    document.addEventListener('mouseup', endSelection);
}

function updateSelection(e) {
    if (!isSelecting) return;
    
    const rect = document.getElementById('timelineTracks').getBoundingClientRect();
    const x = e.clientX - rect.left + document.getElementById('timelineTracks').scrollLeft;
    const y = e.clientY - rect.top;
    
    const selRect = document.getElementById('selectionRect');
    const width = Math.abs(x - selectionStart.x);
    const height = Math.abs(y - selectionStart.y);
    const left = Math.min(x, selectionStart.x);
    const top = Math.min(y, selectionStart.y);
    
    selRect.style.left = left + 'px';
    selRect.style.top = top + 'px';
    selRect.style.width = width + 'px';
    selRect.style.height = height + 'px';
    
    // Select clips in rectangle
    document.querySelectorAll('.clip').forEach(clip => {
        const clipRect = clip.getBoundingClientRect();
        const containerRect = document.getElementById('timelineTracks').getBoundingClientRect();
        const clipLeft = clipRect.left - containerRect.left + document.getElementById('timelineTracks').scrollLeft;
        const clipTop = clipRect.top - containerRect.top;
        
        if (clipLeft < left + width && clipLeft + clipRect.width > left &&
            clipTop < top + height && clipTop + clipRect.height > top) {
            clip.classList.add('selected');
            selectedClips.add(parseInt(clip.id.split('-')[1]));
        } else {
            clip.classList.remove('selected');
            selectedClips.delete(parseInt(clip.id.split('-')[1]));
        }
    });
}

function endSelection() {
    isSelecting = false;
    document.getElementById('selectionRect').style.display = 'none';
    document.removeEventListener('mousemove', updateSelection);
    document.removeEventListener('mouseup', endSelection);
}

function splitAtPlayhead() {
    if (selectedClips.size === 0) return;
    
    const clipId = Array.from(selectedClips)[0];
    tracks.forEach(track => {
        const clipIndex = track.clips.findIndex(c => c.id === clipId);
        if (clipIndex !== -1) {
            const clip = track.clips[clipIndex];
            const splitPoint = currentTime - clip.startTime;
            
            if (splitPoint > 0 && splitPoint < clip.duration) {
                // Create two new clips
                const clip1 = {
                    ...clip,
                    id: Date.now(),
                    duration: splitPoint,
                    buffer: clip.buffer // Ideally we'd slice the buffer
                };
                
                const clip2 = {
                    ...clip,
                    id: Date.now() + 1,
                    startTime: currentTime,
                    duration: clip.duration - splitPoint
                };
                
                track.clips.splice(clipIndex, 1, clip1, clip2);
                refreshTimeline();
            }
        }
    });
}

function deleteSelection() {
    selectedClips.forEach(id => {
        tracks.forEach(track => {
            track.clips = track.clips.filter(c => c.id !== id);
        });
        const el = document.getElementById(`clip-${id}`);
        if (el) el.remove();
    });
    selectedClips.clear();
}

function duplicateSelection() {
    selectedClips.forEach(id => {
        tracks.forEach(track => {
            const clip = track.clips.find(c => c.id === id);
            if (clip) {
                const newClip = {
                    ...clip,
                    id: Date.now() + Math.random(),
                    startTime: clip.startTime + clip.duration
                };
                track.clips.push(newClip);
                renderClip(newClip, track.id);
            }
        });
    });
}

// Piano Roll
function createPianoKeys() {
    const container = document.getElementById('pianoKeys');
    const notes = ['C', 'B', 'A#', 'A', 'G#', 'G', 'F#', 'F', 'E', 'D#', 'D', 'C#'];
    
    for (let octave = 6; octave >= 2; octave--) {
        notes.forEach(note => {
            const key = document.createElement('div');
            key.className = 'piano-key' + (note.includes('#') ? ' black' : '');
            key.textContent = note + octave;
            key.dataset.note = note + octave;
            container.appendChild(key);
        });
    }
}

function addMidiNote(e) {
    if (tracks[currentTrack].type !== 'midi') {
        alert('Please select a MIDI track first');
        return;
    }
    
    const rect = e.target.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    const note = Math.floor(y / 20);
    const time = x / 40; // 40px per beat
    
    const midiNote = {
        id: Date.now(),
        note: 72 - note, // C4 = 60
        time: time,
        duration: 0.5,
        velocity: 100
    };
    
    tracks[currentTrack].midiNotes.push(midiNote);
    renderMidiNote(midiNote);
}

function renderMidiNote(note) {
    const grid = document.getElementById('pianoGrid');
    const div = document.createElement('div');
    div.className = 'midi-note';
    div.style.left = (note.time * 40) + 'px';
    div.style.top = ((72 - note.note) * 20) + 'px';
    div.style.width = (note.duration * 40) + 'px';
    div.style.height = '18px';
    grid.appendChild(div);
}

// AI Features
function showAIModal() {
    document.getElementById('aiModal').classList.add('active');
}

function closeAIModal() {
    document.getElementById('aiModal').classList.remove('active');
}

function generateAIMusic() {
    const style = document.getElementById('aiStyle').value;
    const duration = parseInt(document.getElementById('aiDuration').value);
    
    closeAIModal();
    showStatus(`Generating ${style} music...`, 'success');
    
    // Simulate generation with algorithmic composition
    setTimeout(() => {
        generateMelodyPattern(style, duration);
    }, 1500);
}

function generateMelodyPattern(style, bars) {
    const scales = {
        pop: [60, 62, 64, 65, 67, 69, 71], // C Major
        rock: [60, 63, 65, 67, 70], // C Minor pentatonic
        electronic: [60, 62, 64, 67, 69], // C Major pentatonic
        jazz: [60, 62, 63, 65, 67, 69, 71], // C Dorian
        lofi: [60, 63, 65, 67, 70, 72] // C Minor with extensions
    };
    
    const scale = scales[style] || scales.pop;
    const notes = [];
    
    for (let bar = 0; bar < bars; bar++) {
        for (let beat = 0; beat < 4; beat++) {
            if (Math.random() > 0.3) { // 70% chance of note
                const note = scale[Math.floor(Math.random() * scale.length)];
                notes.push({
                    id: Date.now() + Math.random(),
                    note: note,
                    time: bar * 4 + beat,
                    duration: Math.random() > 0.5 ? 1 : 0.5,
                    velocity: 80 + Math.random() * 40
                });
            }
        }
    }
    
    // Add to current track
    if (tracks[currentTrack].type === 'midi') {
        tracks[currentTrack].midiNotes.push(...notes);
        notes.forEach(renderMidiNote);
        showStatus('Melody generated!', 'success');
    } else {
        // Create synth buffer for audio track
        createSynthBuffer(notes);
    }
}

function createSynthBuffer(notes) {
    const duration = Math.max(...notes.map(n => n.time + n.duration));
    const sampleRate = audioCtx.sampleRate;
    const buffer = audioCtx.createBuffer(2, duration * sampleRate, sampleRate);
    
    notes.forEach(note => {
        const freq = 440 * Math.pow(2, (note.note - 69) / 12);
        const startSample = note.time * sampleRate;
        const endSample = (note.time + note.duration) * sampleRate;
        
        for (let channel = 0; channel < 2; channel++) {
            const data = buffer.getChannelData(channel);
            for (let i = startSample; i < endSample; i++) {
                const t = (i - startSample) / sampleRate;
                const envelope = Math.exp(-t * 3); // Decay
                data[i] += Math.sin(2 * Math.PI * freq * t) * envelope * 0.3;
            }
        }
    });
    
    const clip = {
        id: Date.now(),
        buffer: buffer,
        startTime: currentTime,
        duration: duration,
        name: 'AI Generated'
    };
    
    tracks[currentTrack].clips.push(clip);
    renderClip(clip, currentTrack);
    showStatus('AI Audio generated!', 'success');
}

function generateChords() {
    const progressions = [
        [60, 64, 67], // C Major
        [57, 60, 64], // F Major
        [62, 65, 69], // D Minor
        [59, 62, 65]  // G Major
    ];
    
    const chords = [];
    for (let i = 0; i < 4; i++) {
        const chord = progressions[i % progressions.length];
        chord.forEach(note => {
            chords.push({
                id: Date.now() + Math.random(),
                note: note,
                time: i * 2,
                duration: 2,
                velocity: 70
            });
        });
    }
    
    if (tracks[currentTrack].type === 'midi') {
        tracks[currentTrack].midiNotes.push(...chords);
        chords.forEach(renderMidiNote);
    }
}

function smartMaster() {
    // Auto-gain staging
    tracks.forEach(track => {
        if (track.clips.length > 0) {
            // Analyze loudness and adjust
            track.volume = Math.min(1.0, 0.8 / (track.clips.length * 0.3));
            track.gainNode.gain.value = track.volume;
        }
    });
    showStatus('Auto-mix applied!', 'success');
}

function removeSilence() {
    tracks[currentTrack].clips.forEach(clip => {
        if (clip.buffer) {
            // Trim start silence
            const data = clip.buffer.getChannelData(0);
            let startSample = 0;
            while (startSample < data.length && Math.abs(data[startSample]) < 0.01) {
                startSample++;
            }
            
            if (startSample > 0) {
                clip.startTime += startSample / audioCtx.sampleRate;
                clip.duration -= startSample / audioCtx.sampleRate;
                const el = document.getElementById(`clip-${clip.id}`);
                if (el) {
                    el.style.left = (clip.startTime * pixelsPerSecond) + 'px';
                    el.style.width = (clip.duration * pixelsPerSecond) + 'px';
                }
            }
        }
    });
    showStatus('Silence removed!', 'success');
}

function styleTransfer() {
    // Simulate style transfer with different EQ curves
    const styles = {
        modern: [0, 2, 1, 0, 1, 2, 1], // Bass and treble boost
        vintage: [2, 1, 0, -1, 0, 1, 2], // Mid hump
        bright: [-1, 0, 1, 2, 2, 1, 0]  // Treble boost
    };
    
    showStatus('Style transfer applied (EQ curve adjusted)', 'success');
}

function quantizeAudio() {
    // Snap clip start times to grid
    const gridSize = 60 / bpm; // One beat
    tracks[currentTrack].clips.forEach(clip => {
        const nearestBeat = Math.round(clip.startTime / gridSize) * gridSize;
        clip.startTime = nearestBeat;
        const el = document.getElementById(`clip-${clip.id}`);
        if (el) el.style.left = (clip.startTime * pixelsPerSecond) + 'px';
    });
    showStatus('Audio quantized to grid!', 'success');
}

// Effects
function updateEffectsPanel() {
    const container = document.getElementById('effectsChain');
    container.innerHTML = '';
    
    const track = tracks[currentTrack];
    if (!track) return;
    
    ['Gate', 'EQ', 'Compressor', 'Reverb', 'Delay', 'Distortion'].forEach((effect, i) => {
        const slot = document.createElement('div');
        slot.className = 'effect-slot' + (track.effects[i] ? ' occupied' : '');
        slot.innerHTML = `
            <span>${effect}</span>
            ${track.effects[i] ? '<button onclick="removeEffect(' + i + ')" style="background: none; border: none; color: #ef4444; cursor: pointer;">‚úï</button>' : '<span style="font-size: 0.8rem;">Click to add</span>'}
        `;
        slot.onclick = () => addEffect(i, effect);
        container.appendChild(slot);
        
        if (track.effects[i]) {
            const params = document.createElement('div');
            params.className = 'effect-param';
            params.innerHTML = `
                <label>Amount:</label>
                <input type="range" min="0" max="100" value="${track.effects[i].amount}" oninput="updateEffect(${i}, this.value)">
            `;
            container.appendChild(params);
        }
    });
}

function addEffect(index, type) {
    const track = tracks[currentTrack];
    track.effects[index] = { type, amount: 50 };
    updateEffectsPanel();
    
    // Create audio node
    const node = createEffectNode(type);
    if (node) {
        track.gainNode.disconnect();
        track.gainNode.connect(node);
        node.connect(track.pannerNode);
    }
}

function createEffectNode(type) {
    switch(type) {
        case 'Reverb':
            // Simple convolver simulation with delay
            const convolver = audioCtx.createConvolver();
            // Would normally load impulse response
            return convolver;
        case 'Delay':
            const delay = audioCtx.createDelay();
            delay.delayTime.value = 0.3;
            return delay;
        case 'Distortion':
            const waveshaper = audioCtx.createWaveShaper();
            waveshaper.curve = makeDistortionCurve(50);
            return waveshaper;
        case 'Compressor':
            const comp = audioCtx.createDynamicsCompressor();
            comp.threshold.value = -24;
            comp.ratio.value = 4;
            return comp;
        default:
            return null;
    }
}

function makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i) {
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
}

function removeEffect(index) {
    tracks[currentTrack].effects[index] = null;
    updateEffectsPanel();
}

function updateEffect(index, value) {
    if (tracks[currentTrack].effects[index]) {
        tracks[currentTrack].effects[index].amount = value;
    }
}

// Loop Library
function addLoop(type) {
    // Generate loop buffers
    const duration = 4 * (60 / bpm); // 4 beats
    const sampleRate = audioCtx.sampleRate;
    const buffer = audioCtx.createBuffer(2, duration * sampleRate, sampleRate);
    
    if (type === 'trap') {
        // Simple trap beat pattern
        for (let i = 0; i < 4; i++) {
            const offset = (i * duration / 4) * sampleRate;
            for (let j = 0; j < sampleRate * 0.1; j++) {
                if (offset + j < buffer.length) {
                    buffer.getChannelData(0)[offset + j] = (Math.random() - 0.5) * 0.5;
                    buffer.getChannelData(1)[offset + j] = (Math.random() - 0.5) * 0.5;
                }
            }
        }
    } else if (type === 'arp') {
        // Arpeggio
        const notes = [523.25, 659.25, 783.99, 1046.50]; // C E G C
        notes.forEach((freq, i) => {
            const offset = (i * duration / 4) * sampleRate;
            for (let j = 0; j < sampleRate * 0.2; j++) {
                const t = j / sampleRate;
                const sample = Math.sin(2 * Math.PI * freq * t) * Math.exp(-t * 5) * 0.3;
                if (offset + j < buffer.length) {
                    buffer.getChannelData(0)[offset + j] = sample;
                    buffer.getChannelData(1)[offset + j] = sample;
                }
            }
        });
    }
    
    const clip = {
        id: Date.now(),
        buffer: buffer,
        startTime: currentTime,
        duration: duration,
        name: type + ' loop'
    };
    
    tracks[currentTrack].clips.push(clip);
    renderClip(clip, currentTrack);
}

// Panel Switching
function switchPanel(panel) {
    document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.piano-roll, .mixer-view, .effects-rack, .loop-library, .ai-panel').forEach(p => p.classList.remove('active'));
    
    event.target.classList.add('active');
    
    switch(panel) {
        case 'piano': document.getElementById('pianoPanel').classList.add('active'); break;
        case 'mixer': document.getElementById('mixerPanel').classList.add('active'); break;
        case 'effects': document.getElementById('effectsPanel').classList.add('active'); break;
        case 'loops': document.getElementById('loopsPanel').classList.add('active'); break;
        case 'ai': document.getElementById('aiPanel').classList.add('active'); break;
    }
}

function showStatus(msg, type) {
    // Simple status implementation
    const div = document.createElement('div');
    div.style.cssText = `position: fixed; top: 80px; right: 20px; background: ${type === 'success' ? '#10b981' : '#ef4444'}; color: white; padding: 1rem; border-radius: 8px; z-index: 9999;`;
    div.textContent = msg;
    document.body.appendChild(div);
    setTimeout(() => div.remove(), 3000);
}
</script>

</body>
</html>
